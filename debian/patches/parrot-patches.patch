Index: metasploit-framework-4.12.23/lib/nessus/README
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/nessus/README
@@ -0,0 +1,66 @@
+Nessus XML RPC library and Nessus Command Line interface to XML RPC
+
+(C) Vlatko Kosturjak, Kost. Distributed under GPL and BSD (dual licensed).
+
+Requirements
+============
+Requirements are quite standard Ruby libraries for HTTPS and XML
+parsing:
+require 'uri'
+require 'net/https'
+require 'rexml/document'
+
+nessus-cli.rb
+=============
+Nessus command line interface for XML-RPC.
+
+Type ./nessus-cli.rb --help for command line options.
+
+Examples:
+---------
+
+./nessus-cli.rb --user john --password doe --scan scan-localhost --wait --output report.xml --target localhost
+
+./nessus-cli.rb --user user --password pass --scan localhost-scan --wait 5 -D --output report-localhost.xml --target localhost --verbose 
+
+./nessus-cli.rb --user user --password pass --scan localhost-scan --wait 5 -D --output report-localhost.xml --target 127.0.0.1 --verbose --policy mypolicy --url https://localhost:8834
+
+Or if you want to have detached scans:
+--------------------------------------
+
+./nessus-cli.rb --user user --password pass --scan localhost-scan --target 127.0.0.1 --policy mypolicy
+
+./nessus-cli.rb --user user --password pass --list-scans 
+
+./nessus-cli.rb --user user --password pass --pause 5329fae9-fb1d-0c67-a401-a0db12637c0d5bcd67900d34e00e
+
+./nessus-cli.rb --user user --password pass --resume 5329fae9-fb1d-0c67-a401-a0db12637c0d5bcd67900d34e00e
+
+./nessus-cli.rb --user user --password pass --stop 5329fae9-fb1d-0c67-a401-a0db12637c0d5bcd67900d34e00e
+
+./nessus-cli.rb --user user --password pass --stop-all
+
+./nessus-cli.rb --user user --password pass --report 5329fae9-fb1d-0c67-a401-a0db12637c0d5bcd67900d34e00e --output report.xml
+
+nessus-xmlrpc.rb
+================
+communicate with Nessus(4.2+) over XML RPC interface
+
+Simple example:
+
+require 'nessus-xmlrpc'
+n=NessusXMLRPC::NessusXMLRPC.new('https://localhost:8834','user','pass');
+# n=NessusXMLRPC::NessusXMLRPC.new('','user','pass'); # it's same
+if n.logged_in
+      id,name = n.policy_get_first
+      puts "using policy ID: " + id + " with name: " + name
+      uid=n.scan_new(id,"textxmlrpc","127.0.0.1")
+      puts "status: " + n.scan_status(uid)
+      while not n.scan_finished(uid)
+              sleep 10
+      end
+      content=n.report_file_download(uid)
+      File.open('report.xml', 'w') {|f| f.write(content) }
+end
+
+Take a look at nessus-cli.rb for more advanced examples.
Index: metasploit-framework-4.12.23/lib/nessus/TODO
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/nessus/TODO
@@ -0,0 +1 @@
+- Error handling, no puts
Index: metasploit-framework-4.12.23/lib/nessus/nessus-cli.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/nessus/nessus-cli.rb
@@ -0,0 +1,382 @@
+#!/usr/bin/env ruby
+# = nessus-cli.rb:  Nessus command line interface for XML-RPC
+# Author:: Vlatko Kosturjak
+# 
+# (C) Vlatko Kosturjak, Kost. Distributed under GPL and BSD (dual licensed).
+
+require 'nessus-xmlrpc'
+require 'getoptlong'
+
+verbose = 0
+debug = 0
+operation = ''
+targets = ''
+deletereport = false
+user = ''
+password = ''
+scanname = ''
+output = ''
+output1 = ''
+wait = ''
+policy = ''
+url = ''
+
+def intro 
+  $stderr.print $0 + ": Nessus command line interface for XML-RPC\n"
+  $stderr.print "(C) Vlatko Kosturjak, Kost. Distributed under GPL.\n"
+  $stderr.print "\n"
+end
+
+intro
+
+def give_help
+  puts <<-EOF
+--user <user>	user for login to Nessus server
+--password <p>	password for login to Nessus server
+--scan <name>	start scan with name
+--target <ip>	specify list of targets, separated by comma
+--policy <pol>	specify policy to use (name of policy)
+--url <url>	url of Nessus server (default: localhost:8834)
+--wait [t]	wait scan to finish (ask in regular periods of <t> for status)
+--output <f>	output report XML to file <f>
+--output1 <f>	output report XML v1 to file <f>
+--reportdelete	delete report after finish or delete report by id (if alone)
+--stop <id>	stop scan identified by <id>
+--stop-all	stop all scans
+--pause <id>	pause scan identified by <id>
+--pause-all	pause all scans
+--resume <id>	resume scan identified by <id>
+--resume-all	resume all scans
+--report <id>	download report identified by <id>
+--list-scans	list scans
+--list-policy	list policies
+--status <id>	get status of scan by <id>
+--verbose	be verbose
+--debug		be even more verbose
+--help		this help
+
+Examples: 
+#{$0} --user john --password doe --scan scan-localhost --wait --output report.xml --target localhost
+EOF
+  exit 0
+end
+
+if ARGV.length < 1
+  give_help
+end
+
+opt = GetoptLong.new(
+  ["--help", "-h", GetoptLong::NO_ARGUMENT],
+  ["--verbose", "-v", GetoptLong::OPTIONAL_ARGUMENT],
+  ["--target", "-t", GetoptLong::REQUIRED_ARGUMENT],
+  ["--user", "-u", GetoptLong::REQUIRED_ARGUMENT],
+  ["--password", "-p", GetoptLong::REQUIRED_ARGUMENT],
+  ["--policy", "-P", GetoptLong::REQUIRED_ARGUMENT],
+  ["--url", "-U", GetoptLong::REQUIRED_ARGUMENT],
+  ["--deletereport", "-D", GetoptLong::OPTIONAL_ARGUMENT],
+  ["--wait", "-w", GetoptLong::OPTIONAL_ARGUMENT],
+  ["--scan", "-s", GetoptLong::REQUIRED_ARGUMENT],
+  ["--list-scans", "-l", GetoptLong::NO_ARGUMENT],
+  ["--list-policy", "-L", GetoptLong::NO_ARGUMENT],
+  ["--status", "-W", GetoptLong::REQUIRED_ARGUMENT],
+  ["--stop", "-S", GetoptLong::REQUIRED_ARGUMENT],
+  ["--stop-all", "-a", GetoptLong::NO_ARGUMENT],
+  ["--pause", "-q", GetoptLong::REQUIRED_ARGUMENT],
+  ["--pause-all", "-Q", GetoptLong::NO_ARGUMENT],
+  ["--resume", "-e", GetoptLong::REQUIRED_ARGUMENT],
+  ["--resume-all", "-E", GetoptLong::NO_ARGUMENT],
+  ["--report", "-r", GetoptLong::REQUIRED_ARGUMENT],
+  ["--output", "-o", GetoptLong::REQUIRED_ARGUMENT],
+  ["--output1", "-1", GetoptLong::REQUIRED_ARGUMENT]
+)
+
+def give_error
+  $stderr.print "You used incompatible options, probably you mixed --scan with --stop"
+  $stderr.print "or something similar."
+  exit 0
+end
+
+opt.each do |opt,arg|
+  case opt
+    when	'--help'
+      give_help
+    when	'--user'
+      user = arg
+    when	'--password'
+      password = arg
+    when 	'--stop'
+      if operation == ''
+        operation = "stop"
+        scanname = arg
+      else
+        give_error
+      end
+    when 	'--pause'
+      if operation == ''
+        operation = "pause"
+        scanname = arg
+      else
+        give_error
+      end
+    when 	'--resume'
+      if operation == ''
+        operation = "resume"
+        scanname = arg
+      else
+        give_error
+      end
+    when 	'--stop-all'
+      if operation == ''
+        operation = "stop-all"
+      else
+        give_error
+      end
+    when 	'--pause-all'
+      if operation == ''
+        operation = "pause-all"
+      else
+        give_error
+      end
+    when 	'--resume-all'
+      if operation == ''
+        operation = "resume-all"
+      else
+        give_error
+      end
+    when 	'--report'
+      if operation == ''
+        operation = "report"
+        scanname = arg
+      else
+        give_error
+      end
+    when 	'--scan'
+      if operation == ''
+        operation = "scan"
+        scanname = arg
+      else
+        give_error
+      end
+    when	'--target'
+      if arg[0..6] == 'file://'
+        f = File.open(arg[7..-1], "r")
+        f.each_line do |line|
+          line=line.chomp
+          line=line.strip
+          unless line == '' or line == nil
+            if targets == ''
+              targets = line
+            else
+              targets = targets + "," + line
+            end
+          end
+        end
+        f.close
+      else
+        # if there's multiple target options, add comma
+        if targets == ''
+          targets = arg
+          
+        else
+          targets = targets + "," + arg
+        end
+      end
+    when	'--wait'
+      if arg == ''
+        wait = 15
+      else
+        wait = arg.to_i
+      end
+    when	'--reportdelete'
+      if arg == ''
+        deletereport=true
+      else
+        operation = "reportdelete"
+        scanname = arg
+      end
+
+    when	'--output'
+      output = arg
+    when	'--output1'
+      output1 = arg
+    when	'--policy'
+      policy = arg
+    when	'--status'
+      if operation == ''
+        operation = "status"
+        scanname = arg
+      else
+        give_error
+      end
+    when	'--url'
+      url = arg
+    when 	'--verbose'
+      if arg == ''
+        verbose += 1
+      else
+        verbose = arg.to_i
+      end
+    when 	'--debug'
+      if arg == ''
+        debug += 1
+      else
+        debug = arg.to_i
+      end
+    when	'--list-scans'
+      if operation == ''
+        operation = "list-scans"
+        scanname = arg
+      else
+        give_error
+      end
+    when	'--list-policy'
+      if operation == ''
+        operation = "list-policy"
+        scanname = arg
+      else
+        give_error
+      end
+  end
+end
+
+if (user == '') or (password == '')
+  $stderr.print "User and password is required to login to Nessus server"
+  $stderr.print "Try --help!"
+  exit 1
+end 
+
+$stderr.print "[i] Targets: " + targets +"\n" if verbose > 0 
+$stderr.print "[i] Connecting to nessus server: " if verbose > 0 
+n=NessusXMLRPC::NessusXMLRPC.new(url,user,password) 
+if n.logged_in 
+  $stderr.print "OK!\n" if verbose > 0
+else
+  $stderr.print "[e] Error connecting/logging to the server!\n" 
+  exit 2
+end
+
+case operation
+  when "scan"
+    if policy == ''
+      $stderr.print "[w] Policy not defined, using first served from the server\n"
+      pid,name = n.policy_get_first
+      $stderr.print "[w] using policy id " + pid + " with name " + name + "\n"
+    else
+      pid=n.policy_get_id(policy)
+      if pid == ''
+        $stderr.print "[e] policy doesn't exit: " + policy + "\n"
+        exit 3
+      end
+    end	
+    if targets == ''
+      $stderr.print "[w] Targets not defined, using localhost as target\n"
+      targets = '127.0.0.1'
+    end
+    $stderr.print "[i] Initiating scan with targets: "+targets+': ' if verbose > 0
+    uid=n.scan_new(pid,scanname,targets)
+    $stderr.print "done\n" if verbose > 0
+    unless wait == ''
+      while not n.scan_finished(uid)
+        $stderr.print "[v] Sleeping for " + wait.to_s() + ": " if verbose > 1			
+        sleep wait
+        $stderr.print "done\n" if verbose > 1
+        stat = n.scan_status(uid)
+        print "\r" + stat if verbose > 0
+      end	
+    else
+      puts uid
+      exit 0
+    end	
+    unless output == ''
+      $stderr.print "[i] Output XML report to file: "+output if verbose > 0
+      content=n.report_file_download(uid)	
+      File.open(output, 'w') {|f| f.write(content) }	
+      $stderr.print ": done\n" if verbose > 0
+    end
+    unless output1 == ''
+      $stderr.print "[i] Output XML1 report to file: "+output1 if verbose > 0
+      content=n.report_file1_download(uid)	
+      File.open(output, 'w') {|f| f.write(content) }	
+      $stderr.print ": done\n" if verbose > 0
+    end
+    if deletereport
+      $stderr.print "[i] Deleting report: " if verbose > 0
+      n.report_delete(uid)
+      $stderr.print "done\n" if verbose > 0
+    end
+  when "report"
+    uid=scanname
+    if (output == '') and (output1 == '') 
+      $stderr.print "[e] You want report, but specify filename with --output or output1\n"
+    end
+    unless output == ''
+      $stderr.print "[i] Output XML report to file: "+output if verbose > 0
+      content=n.report_file_download(uid)	
+      File.open(output, 'w') {|f| f.write(content) }	
+      $stderr.print ": done\n" if verbose > 0
+    end
+    unless output1 == ''
+      $stderr.print "[i] Output XML1 report to file: "+output1 if verbose > 0
+      content=n.report1_file_download(uid)	
+      File.open(output, 'w') {|f| f.write(content) }	
+      $stderr.print ": done\n" if verbose > 0
+    end
+    if deletereport
+      $stderr.print "[i] Deleting report: " if verbose > 0
+      n.report_delete(uid)
+      $stderr.print "done\n" if verbose > 0
+    end
+  when "stop"
+    $stderr.print "[i] Stopping scan: " + scanname if verbose > 0
+    n.scan_stop(scanname)
+    $stderr.print "done\n" if verbose > 0
+  when "stop-all"
+    $stderr.print "[i] Stopping all scans: " if verbose > 0	
+    list=n.scan_stop_all
+    $stderr.print "done\n" if verbose > 0
+    if verbose > 1
+      list.each {|uuid| puts "[v] Stop all: " + uuid }
+    end
+  when "pause"
+    $stderr.print "[i] Pausing scan: " + scanname if verbose > 0
+    n.scan_pause(scanname)
+    $stderr.print "done\n" if verbose > 0
+  when "pause-all"
+    $stderr.print "[i] Pausing all scans: " if verbose > 0	
+    list=n.scan_pause_all
+    $stderr.print "done\n" if verbose > 0
+    if verbose > 1
+      list.each {|uuid| puts "[v] Pause all: " + uuid }
+    end
+  when "resume"
+    $stderr.print "[i] Resuming scan: " + scanname if verbose > 0
+    n.scan_resume(scanname)
+    $stderr.print "done\n" if verbose > 0
+  when "resume-all"
+    $stderr.print "[i] Resuming all scans: " if verbose > 0	
+    list=n.scan_resume_all
+    $stderr.print "done\n" if verbose > 0
+    if verbose > 1
+      list.each {|uuid| puts "[v] Resume all: " + uuid }
+    end
+  when "reportdelete"
+    $stderr.print "[i] Deleting report: " + scanname if verbose > 0
+    n.report_delete(scanname)
+    $stderr.print "done\n" if verbose > 0
+  when "status"
+    puts "status: " + n.scan_status(scanname)	
+  when "list-scans"
+    list=n.scan_list_hash
+    list.each {|scan| 
+      puts scan['id']+":"+scan['name']+":"+ \
+        scan['current']+"/"+scan['total']
+    }
+  when "list-policy"
+    list=n.policy_list_names
+    list.each {|policy| 
+      puts policy 
+    }
+    
+end
+
+$stderr.print "[v] End reached.\n" if verbose > 1
Index: metasploit-framework-4.12.23/lib/nessus/nessus-xmlrpc.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/nessus/nessus-xmlrpc.rb
@@ -0,0 +1,308 @@
+require 'net/http'
+
+module Nessus
+  class Client
+    class << self
+      @connection
+      @token
+    end
+     
+    def initialize(host, username = nil, password = nil, ssl_option = nil)
+      uri = URI.parse(host)
+      @connection = Net::HTTP.new(uri.host, uri.port)
+      @connection.use_ssl = true
+      if ssl_option == "ssl_verify"
+        @connection.verify_mode = OpenSSL::SSL::VERIFY_PEER
+      else
+        @connection.verify_mode = OpenSSL::SSL::VERIFY_NONE
+      end
+        
+      yield @connection if block_given?
+        authenticate(username, password) if username && password
+    end
+ 
+    def authenticate(username, password)
+      payload = {
+        :username => username, 
+        :password => password, 
+        :json => 1
+      }
+      res = http_post(:uri=>"/session", :data=>payload)
+      if res['token']
+        @token = "token=#{res['token']}"
+        return true
+      else
+        false
+      end
+    end
+
+    def x_cookie
+      {'X-Cookie'=>@token}
+    end
+
+    alias_method :login, :authenticate
+     
+    def authenticated
+      if (@token && @token.include?('token='))
+        return true
+      else
+        return false
+      end
+    end
+
+    def get_server_properties
+      http_get(:uri=>"/server/properties", :fields=>x_cookie)
+    end
+  
+    def user_add(username, password, permissions, type)
+      payload = {
+        :username => username, 
+        :password => password, 
+        :permissions => permissions, 
+        :type => type, 
+        :json => 1
+      }
+      http_post(:uri=>"/users", :fields=>x_cookie, :data=>payload)
+    end
+      
+    def user_delete(user_id)
+      res = http_delete(:uri=>"/users/#{user_id}", :fields=>x_cookie)
+      return res.code
+    end
+      
+    def user_chpasswd(user_id, password)
+      payload = {
+        :password => password, 
+        :json => 1
+      }
+      res = http_put(:uri=>"/users/#{user_id}/chpasswd", :data=>payload, :fields=>x_cookie)
+      return res.code
+    end
+      
+    def user_logout
+      res = http_delete(:uri=>"/session", :fields=>x_cookie)
+      return res.code
+    end
+
+    def list_policies
+      http_get(:uri=>"/policies", :fields=>x_cookie)
+    end
+
+    def list_users
+      http_get(:uri=>"/users", :fields=>x_cookie)
+    end
+
+    def list_folders
+      http_get(:uri=>"/folders", :fields=>x_cookie)
+    end
+
+    def list_scanners
+      http_get(:uri=>"/scanners", :fields=>x_cookie)
+    end
+
+    def list_families
+      http_get(:uri=>"/plugins/families", :fields=>x_cookie)
+    end
+
+    def list_plugins(family_id)
+      http_get(:uri=>"/plugins/families/#{family_id}", :fields=>x_cookie)
+    end
+
+    def list_template(type)
+      res = http_get(:uri=>"/editor/#{type}/templates", :fields=>x_cookie)
+    end
+
+    def plugin_details(plugin_id)
+      http_get(:uri=>"/plugins/plugin/#{plugin_id}", :fields=>x_cookie)
+    end
+
+    def is_admin
+      res = http_get(:uri=>"/session", :fields=>x_cookie)
+      if res['permissions'] == 128
+        return true
+      else
+        return false
+      end
+    end
+
+    def server_properties
+      http_get(:uri=>"/server/properties", :fields=>x_cookie)
+    end
+
+    def scan_create(uuid, name, description, targets)
+      payload = {
+        :uuid => uuid, 
+        :settings => {
+          :name => name, 
+          :description => description, 
+          :text_targets => targets
+          },
+        :json => 1
+      }.to_json
+      http_post(:uri=>"/scans", :body=>payload, :fields=>x_cookie, :ctype=>'application/json')
+    end
+
+    def scan_launch(scan_id)
+      http_post(:uri=>"/scans/#{scan_id}/launch", :fields=>x_cookie)
+    end
+
+    def server_status
+      http_get(:uri=>"/server/status", :fields=>x_cookie)
+    end
+
+    def scan_list
+      http_get(:uri=>"/scans", :fields=>x_cookie)
+    end
+
+    def scan_details(scan_id)
+      http_get(:uri=>"/scans/#{scan_id}", :fields=>x_cookie)
+    end
+
+    def scan_pause(scan_id)
+      http_post(:uri=>"/scans/#{scan_id}/pause", :fields=>x_cookie)
+    end
+
+    def scan_resume(scan_id)
+      http_post(:uri=>"/scans/#{scan_id}/resume", :fields=>x_cookie)
+    end
+
+    def scan_stop(scan_id)
+      http_post(:uri=>"/scans/#{scan_id}/stop", :fields=>x_cookie)
+    end
+
+    def scan_export(scan_id, format)
+      payload = {
+        :format => format
+      }.to_json
+      http_post(:uri=>"/scans/#{scan_id}/export", :body=>payload, :ctype=>'application/json', :fields=>x_cookie)
+    end
+
+    def scan_export_status(scan_id, file_id)
+      request = Net::HTTP::Get.new("/scans/#{scan_id}/export/#{file_id}/status")
+      request.add_field("X-Cookie", @token)
+      res = @connection.request(request)
+      if res.code == "200"
+        return "ready"
+      else
+        res = JSON.parse(res.body)
+        return res
+      end
+    end
+
+    def policy_delete(policy_id)
+      res = http_delete(:uri=>"/policies/#{policy_id}", :fields=>x_cookie)
+      return res.code
+    end
+
+    def host_detail(scan_id, host_id)
+      res = http_get(:uri=>"/scans/#{scan_id}/hosts/#{host_id}", :fields=>x_cookie)
+    end
+
+    def report_download(scan_id, file_id)
+      res = http_get(:uri=>"/scans/#{scan_id}/export/#{file_id}/download", :raw_content=> true, :fields=>x_cookie)
+    end
+
+    private
+
+    def http_put(opts={})
+      uri    = opts[:uri]
+      data   = opts[:data]
+      fields = opts[:fields] || {}
+      res    = nil
+
+      req = Net::HTTP::Put.new(uri)
+      req.set_form_data(data) unless data.blank?
+      fields.each_pair do |name, value|
+        req.add_field(name, value)
+      end
+
+      begin
+        res = @connection.request(req)
+      rescue URI::InvalidURIError
+        return res
+      end
+
+      res
+    end
+
+    def http_delete(opts={})
+      uri    = opts[:uri]
+      fields = opts[:fields] || {}
+      res    = nil
+
+      req = Net::HTTP::Delete.new(uri)
+
+      fields.each_pair do |name, value|
+        req.add_field(name, value)
+      end
+
+      begin
+        res = @connection.request(req)
+      rescue URI::InvalidURIError
+        return res
+      end
+
+      res
+    end
+
+    def http_get(opts={})
+      uri    = opts[:uri]
+      fields = opts[:fields] || {}
+      raw_content = opts[:raw_content] || false
+      json   = {}
+
+      req = Net::HTTP::Get.new(uri)
+      fields.each_pair do |name, value|
+        req.add_field(name, value)
+      end
+
+      begin
+        res = @connection.request(req)
+      rescue URI::InvalidURIError
+        return json
+      end
+      if !raw_content
+        parse_json(res.body)
+      else
+        res.body
+      end
+    end
+
+    def http_post(opts={})
+      uri    = opts[:uri]
+      data   = opts[:data]
+      fields = opts[:fields] || {}
+      body   = opts[:body]
+      ctype  = opts[:ctype]
+      json   = {}
+
+      req = Net::HTTP::Post.new(uri)
+      req.set_form_data(data) unless data.blank?
+      req.body = body unless body.blank?
+      req['Content-Type'] = ctype unless ctype.blank?
+      fields.each_pair do |name, value|
+        req.add_field(name, value)
+      end
+
+      begin
+        res = @connection.request(req)
+      rescue URI::InvalidURIError
+        return json
+      end
+
+      parse_json(res.body)
+    end
+
+    def parse_json(body)
+      buf = {}
+
+      begin
+        buf = JSON.parse(body)
+      rescue JSON::ParserError
+      end
+
+      buf
+    end
+
+  end
+end
Index: metasploit-framework-4.12.23/lib/openvas/openvas-omp.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/openvas/openvas-omp.rb
@@ -0,0 +1,640 @@
+#!/usr/bin/env ruby
+#
+# This plugin provides integration with OpenVAS. Written by kost and
+# averagesecurityguy.
+#
+# Distributed under MIT license: 
+# http://www.opensource.org/licenses/mit-license.php
+#
+
+require 'socket' 
+require 'timeout'
+require 'openssl'
+require 'rexml/document'
+require 'rexml/text'
+require 'base64'
+
+# OpenVASOMP module
+# 
+# Usage: require 'openvas-omp'
+
+module OpenVASOMP
+
+#------------------------------
+# Error Classes
+#------------------------------
+  class OMPError < :: RuntimeError
+    attr_accessor :reason
+    def initialize(reason = '')
+      self.reason = reason
+    end
+    def to_s
+      "OpenVAS OMP: #{self.reason}"
+    end
+  end
+
+  class OMPConnectionError < OMPError
+    def initialize
+      self.reason = "Could not connect to server"
+    end
+  end
+
+  class OMPResponseError < OMPError
+    def initialize
+      self.reason = "Error in OMP request/response"
+    end
+  end
+
+  class OMPAuthError < OMPError
+    def initialize
+      self.reason = "Authentication failed"
+    end
+  end
+
+  class XMLParsingError < OMPError
+    def initialize
+      self.reason = "XML parsing failed"
+    end
+  end
+
+
+#------------------------------
+# Connection Class
+#------------------------------
+  class OpenVASConnection
+    attr_accessor :socket, :bufsize, :debug
+
+    def initialize(host="127.0.0.1", port=9390, debug=false)
+      @host = host
+      @port = port
+      @socket = nil
+      @bufsize = 16384
+      @debug = debug
+    end
+
+    def connect
+      if @debug then puts "Connecting to server #{@host} on port #{@port}" end
+      plain_socket = TCPSocket.open(@host, @port)
+      ssl_context = OpenSSL::SSL::SSLContext.new()
+      @socket = OpenSSL::SSL::SSLSocket.new(plain_socket, ssl_context)
+      @socket.sync_close = true
+      @socket.connect
+    end
+      
+    def disconnect
+      if @debug then
+        puts "Closing connection to server #{@host} on port #{@port}" end
+      if @socket then @socket.close end
+    end
+
+    def sendrecv(data)
+      # Send the data
+      if @debug then puts "Preparing to send data" end
+      if not @socket then connect end
+      if @debug then puts "SENDING: " + data end
+      @socket.puts(data)
+
+      # Receive the response
+      resp = ''
+      size = 0
+      begin	
+        begin
+          timeout(@read_timeout) {
+              a = @socket.sysread(@bufsize)
+              size = a.length
+              resp << a
+          }
+        rescue Timeout::Error
+          size = 0
+        rescue EOFError
+          raise OMPResponseError
+        end
+      end while size >= @bufsize
+      
+      if @debug then puts "RECEIVED: " + resp end
+      return resp
+    end
+  end
+    
+
+#------------------------------
+# OpenVASOMP class
+#------------------------------
+  class OpenVASOMP
+    # initialize object: try to connect to OpenVAS using URL, user and password
+    attr_reader :targets, :tasks, :configs, :formats, :reports
+
+    def initialize(user="openvas", pass="openvas", host="localhost", port=9392, debug=false)
+      @debug = debug
+      @token = ''
+      @server = OpenVASConnection.new(host, port, debug)
+      @server.connect
+      login(user, pass)
+      @configs = nil
+      @tasks = nil
+      @targets = nil
+      @formats = nil
+      @reports = nil
+      config_get_all
+      task_get_all
+      target_get_all
+      format_get_all
+      report_get_all
+    end
+
+  #--------------------------
+  # Low level commands. Only
+  # used by OpenVASOMP class.
+  #--------------------------
+    # Nests a string inside an XML tag specified by root
+    def xml_str(root, str)
+      return "<#{root}>#{str}</#{root}>"
+    end
+
+    # Creates an XML root with child elements specified by a hash
+    def xml_elems(root, elems)
+      xml = REXML::Element.new(root)
+      elems.each do |key, val|
+        e = xml.add_element(key)
+        e.text = val
+      end
+      return xml.to_s
+    end
+
+    # Creates and XML element with attributes specified by a hash
+    def xml_attrs(elem, attribs)
+      xml = REXML::Element.new(elem)
+      attribs.each do |key, val|
+        xml.attributes[key] = val
+      end
+      return xml.to_s
+    end
+
+    # Send authentication string and return an XML object (authentication token)
+    def auth_request_xml(request)
+      if @debug
+        puts "Sending Request: #{request}"
+      end
+      resp = @server.sendrecv(request)
+      begin
+        docxml = REXML::Document.new(resp)
+        status = docxml.root.attributes['status'].to_i
+        status_text = docxml.root.attributes['status_text']
+        if @debug
+          puts "Status: #{status}"
+          puts "Status Text: #{status_text}"
+        end
+      rescue
+        raise XMLParsingError
+      end
+
+      return status, status_text
+    end
+
+    # Send string request wrapped with authentication XML and return 
+    # an XML object
+    def omp_request_xml(request)
+      if @debug
+        puts "Sending Request: #{request}"
+      end
+      resp = @server.sendrecv(@token + request)
+      begin
+        # Wrap the response in XML tags to use next_element properly.
+        docxml = REXML::Document.new("<response>" + resp + "</response>")
+        resp = docxml.root.elements['authenticate_response'].next_element
+        status = resp.attributes['status'].to_i
+        status_text = resp.attributes['status_text']	
+        if @debug
+          puts "Status: #{status}"
+          puts "Status Text: #{status_text}"
+        end
+      rescue
+        raise XMLParsingError
+      end
+
+      return status, status_text, resp
+    end
+
+  #--------------------------
+  # Class API methods.
+  #--------------------------
+    # Sets debug level
+    def debug(value)
+      if value == 0
+        @debug = false
+        @server.debug = false
+        return "Debug is deactivated."
+      else
+        @debug = true
+        @server.debug = true
+        return "Debug is activated."
+      end
+    end
+
+    # get OMP version (you don't need to be authenticated)
+    def get_version
+      status, status_text, resp = omp_request_xml("<get_version/>")
+      begin
+        version = resp.elements['version'].text
+        return version
+      rescue
+        raise XMLParsingError 
+      end
+    end
+
+    # login to OpenVAS server. 
+    # if successful returns authentication XML for further usage
+    # if unsuccessful returns empty string
+    def login(user, pass)
+      creds = xml_elems("credentials", {"username"=> user, "password" => pass})
+      req = xml_str("authenticate", creds)
+      status, status_text = auth_request_xml(req)
+
+      if status == 200
+        @token = req
+      else
+        raise OMPAuthError	
+      end
+    end
+
+    # Logout by disconnecting from the server and deleting the
+    # authentication string. There are no sessions in OMP, must
+    # send the credentials every time.
+    def logout
+      @server.disconnect()
+      @token = ''
+    end
+
+#------------------------------
+# Target Functions
+#------------------------------
+
+    # OMP - Get all targets for scanning and returns array of hashes
+    # with following keys: id,name,comment,hosts,max_hosts,in_use
+    #
+    # Usage:
+    # array_of_hashes = target_get_all()
+    # 
+    def target_get_all()
+      begin
+        status, status_text, resp = omp_request_xml("<get_targets/>")
+
+        list = Array.new
+        resp.elements.each('//get_targets_response/target') do |target|
+          td = Hash.new
+          td["id"] = target.attributes["id"]
+          td["name"] = target.elements["name"].text
+          td["comment"] = target.elements["comment"].text
+          td["hosts"] = target.elements["hosts"].text
+          td["max_hosts"] = target.elements["max_hosts"].text
+          td["in_use"] = target.elements["in_use"].text
+          list.push td
+        end
+        @targets = list
+        return list
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # OMP - Create target for scanning
+    #
+    # Usage:
+    #
+    # target_id = ov.target_create("name"=>"localhost",
+    # 	"hosts"=>"127.0.0.1","comment"=>"yes")
+    # 
+    def target_create(name, hosts, comment)
+      req = xml_elems("create_target", {"name"=>name, "hosts"=>hosts, "comment"=>comment})
+
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        target_get_all
+        return "#{status_text}: #{resp.attributes['id']}"
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # OMP - Delete target 
+    #
+    # Usage:
+    #
+    # ov.target_delete(target_id)
+    # 
+    def target_delete(id) 
+      target = @targets[id.to_i]
+      if not target
+        raise OMPError.new("Invalid target id.")
+      end
+      req = xml_attrs("delete_target",{"target_id" => target["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        target_get_all
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+  #--------------------------
+  # Task Functions
+  #--------------------------
+    # In short: Create a task.
+    #
+    # The client uses the create_task command to create a new task. 
+    # 
+    def task_create(name, comment, config_id, target_id)
+      config = @configs[config_id.to_i]
+      target = @targets[target_id.to_i]
+      config = xml_attrs("config", {"id"=>config["id"]})
+      target = xml_attrs("target", {"id"=>target["id"]})
+      namestr = xml_str("name", name)
+      commstr = xml_str("comment", comment)
+      
+      req = xml_str("create_task", namestr + commstr + config + target)
+
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        task_get_all
+        return "#{status_text}: #{resp.attributes['id']}"
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # In short: Delete a task.
+    #
+    # The client uses the delete_task command to delete an existing task,
+    # including all reports associated with the task. 
+    # 
+    def task_delete(task_id) 
+      task = @tasks[task_id.to_i]
+      if not task
+        raise OMPError.new("Invalid task id.")
+      end
+      req = xml_attrs("delete_task",{"task_id" => task["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        task_get_all
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # In short: Get all tasks.
+    #
+    # The client uses the get_tasks command to get task information. 
+    # 
+    def task_get_all()
+      begin
+        status, status_text, resp = omp_request_xml("<get_tasks/>")
+        
+        list = Array.new
+        resp.elements.each('//get_tasks_response/task') do |task|
+          td = Hash.new
+          td["id"] = task.attributes["id"]
+          td["name"] = task.elements["name"].text
+          td["comment"] = task.elements["comment"].text
+          td["status"] = task.elements["status"].text
+          td["progress"] = task.elements["progress"].text
+          list.push td	
+        end
+        @tasks = list
+        return list
+      rescue
+        raise OMPResponseError
+      end
+    end
+
+    # In short: Manually start an existing task.
+    #
+    # The client uses the start_task command to manually start an existing
+    # task.
+    #
+    def task_start(task_id)
+      task = @tasks[task_id.to_i]
+      if not task
+        raise OMPError.new("Invalid task id.")
+      end
+      req = xml_attrs("start_task",{"task_id" => task["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # In short: Stop a running task.
+    #
+    # The client uses the stop_task command to manually stop a running
+    # task.
+    #
+    def task_stop(task_id) 
+      task = @tasks[task_id.to_i]
+      if not task
+        raise OMPError.new("Invalid task id.")
+      end
+      req = xml_attrs("stop_task",{"task_id" => task["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end 
+
+    # In short: Pause a running task.
+    #
+    # The client uses the pause_task command to manually pause a running
+    # task.
+    #
+    def task_pause(task_id) 
+      task = @tasks[task_id.to_i]
+      if not task
+        raise OMPError.new("Invalid task id.")
+      end
+      req = xml_attrs("pause_task",{"task_id" => task["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # In short: Resume task if stopped, else start task.
+    #
+    # The client uses the resume_or_start_task command to manually start
+    # an existing task, ensuring that the task will resume from its
+    # previous position if the task is in the Stopped state.
+    # 
+    def task_resume_or_start(task_id) 
+      task = @tasks[task_id.to_i]
+      if not task
+        raise OMPError.new("Invalid task id.")
+      end
+      req = xml_attrs("resume_or_start_task",{"task_id" => task["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # In short: Resume a puased task
+    #
+    # The client uses the resume_paused_task command to manually resume
+    # a paused task.
+    # 
+    def task_resume_paused(task_id) 
+      task = @tasks[task_id.to_i]
+      if not task
+        raise OMPError.new("Invalid task id.")
+      end
+      req = xml_attrs("resume_paused_task",{"task_id" => task["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+  #--------------------------
+  # Config Functions
+  #--------------------------
+    # OMP - get configs and returns hash as response
+    # hash[config_id]=config_name
+    #
+    # Usage:
+    #
+    # array_of_hashes=ov.config_get_all()
+    # 
+    def config_get_all()
+      begin
+        status, status_text, resp = omp_request_xml("<get_configs/>")
+
+        list = Array.new
+        resp.elements.each('//get_configs_response/config') do |config|
+          c = Hash.new
+          c["id"] = config.attributes["id"]
+          c["name"] = config.elements["name"].text
+          list.push c
+        end
+        @configs = list
+        return list
+      rescue 
+        raise OMPResponseError
+      end
+    end	
+
+
+  #--------------------------
+  # Format Functions
+  #--------------------------
+    # Get a list of report formats
+    def format_get_all()
+      begin
+        status, status_text, resp = omp_request_xml("<get_report_formats/>")
+        if @debug then print resp end
+        
+        list = Array.new
+        resp.elements.each('//get_report_formats_response/report_format') do |report|
+          td = Hash.new
+          td["id"] = report.attributes["id"]
+          td["name"] = report.elements["name"].text
+          td["extension"] = report.elements["extension"].text
+          td["summary"] = report.elements["summary"].text
+          list.push td	
+        end
+        @formats = list
+        return list
+      rescue
+        raise OMPResponseError
+      end
+    end
+
+
+  #--------------------------
+  # Report Functions
+  #--------------------------
+    # Get a list of reports
+    def report_get_all()
+      begin
+        status, status_text, resp = omp_request_xml("<get_reports/>")
+        
+        list = Array.new
+        resp.elements.each('//get_reports_response/report') do |report|
+          td = Hash.new
+          td["id"] = report.attributes["id"]
+          td["task"] = report.elements["report/task/name"].text
+          td["start_time"] = report.elements["report/scan_start"].text
+          td["stop_time"] = report.elements["report/scan_end"].text
+          list.push td	
+        end
+        @reports = list
+        return list
+      rescue
+        raise OMPResponseError
+      end
+    end
+
+    def report_delete(report_id) 
+      report = @reports[report_id.to_i]
+      if not report
+        raise OMPError.new("Invalid report id.")
+      end
+      req = xml_attrs("delete_report",{"report_id" => report["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+        report_get_all
+        return status_text
+      rescue 
+        raise OMPResponseError
+      end
+    end
+
+    # Get a report by id. Must also specify the format_id
+    def report_get_by_id(report_id, format_id)
+      report = @reports[report_id.to_i]
+      if not report
+        raise OMPError.new("Invalid report id.")
+      end
+
+      format = @formats[format_id.to_i]
+      if not format
+        raise OMPError.new("Invalid format id.")
+      end
+
+      req = xml_attrs("get_reports", {"report_id"=>report["id"], "format_id"=>format["id"]})
+      begin
+        status, status_text, resp = omp_request_xml(req)
+      rescue
+        raise OMPResponseError
+      end
+
+      if status == "404"
+        raise OMPError.new(status_text)
+      end
+
+      content_type = resp.elements["report"].attributes["content_type"]
+      report = resp.elements["report"].to_s
+
+      if report == nil
+        raise OMPError.new("The report is empty.")
+      end
+
+      # XML reports are in XML format, everything else is base64 encoded.
+      if content_type == "text/xml"
+        return report
+      else
+        return Base64.decode64(report)
+      end
+    end
+
+    end
+end
Index: metasploit-framework-4.12.23/lib/rex/mime.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/rex/mime.rb
@@ -0,0 +1,10 @@
+# -*- coding: binary -*-
+module Rex
+module MIME
+
+require 'rex/mime/header'
+require 'rex/mime/part'
+require 'rex/mime/message'
+
+end
+end
Index: metasploit-framework-4.12.23/lib/rex/mime/encoding.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/rex/mime/encoding.rb
@@ -0,0 +1,17 @@
+# -*- coding: binary -*-
+module Rex
+module MIME
+# Set of helpers methods to deal with SMTP encoding related topics.
+module Encoding
+
+  # Enforces CRLF on the input data
+  #
+  # @param data [String] The data to CRLF enforce.
+  # @return [String] CRLF enforced data.
+  def force_crlf(data)
+    data.gsub("\r", '').gsub("\n", "\r\n")
+  end
+
+end
+end
+end
Index: metasploit-framework-4.12.23/lib/rex/mime/header.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/rex/mime/header.rb
@@ -0,0 +1,79 @@
+# -*- coding: binary -*-
+module Rex
+module MIME
+class Header
+
+  require 'rex/text'
+
+  attr_accessor :headers
+
+  def initialize(data='')
+    self.headers = []
+    parse(data)
+  end
+
+  def parse(data)
+    prev = nil
+    data.gsub("\r", '').split("\n").each do |line|
+
+      # Handle header folding
+      if (line =~ /^\s+/)
+        # Ignore if there is no previous header
+        next if not prev
+        next if not self.headers[prev]
+        self.headers[prev][1] << line.strip
+        next
+      end
+
+      var, val = line.split(':', 2)
+      next if val.nil?
+
+      self.headers << [ var.to_s.strip, val.to_s.strip ]
+      prev = self.headers.length - 1
+    end
+  end
+
+  def to_s
+    self.headers.map{ |pair| "#{pair[0]}: #{pair[1]}\r\n" }.join
+  end
+
+  def find(idx)
+    if (idx.class == ::Fixnum)
+      return self.headers[idx]
+    else
+      self.headers.each do |pair|
+        if (pair[0] == idx.to_s)
+          return pair
+        end
+      end
+    end
+    nil
+  end
+
+  def set(var, val)
+    hdr = self.find(var) || self.add(var, '')
+    hdr[1] = val
+  end
+
+  def add(var, val)
+    self.headers << [var, val]
+    self.headers[-1]
+  end
+
+  def remove(idx)
+    if (idx.class == ::Fixnum)
+      self.headers.delete_at(idx)
+    else
+      self.headers.each_index do |i|
+        pair = self.headers[i]
+        if (pair[0] == idx.to_s)
+          self.headers.delete_at(i)
+        end
+      end
+    end
+  end
+
+end
+end
+end
+
Index: metasploit-framework-4.12.23/lib/rex/mime/message.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/rex/mime/message.rb
@@ -0,0 +1,144 @@
+# -*- coding: binary -*-
+module Rex
+module MIME
+class Message
+
+  require 'rex/mime/header'
+  require 'rex/mime/part'
+  require 'rex/mime/encoding'
+  require 'rex/text'
+
+  include Rex::MIME::Encoding
+
+  attr_accessor :header, :parts, :bound, :content
+
+
+  def initialize(data=nil)
+    self.header = Rex::MIME::Header.new
+    self.parts  = []
+    self.bound  = "_Part_#{rand(1024)}_#{rand(0xffffffff)}_#{rand(0xffffffff)}"
+    self.content = ''
+    if data
+      head,body = data.split(/\r?\n\r?\n/, 2)
+
+      self.header.parse(head)
+      ctype = self.header.find('Content-Type')
+
+      if ctype && ctype[1] && ctype[1] =~ /multipart\/mixed;\s*boundary="?([A-Za-z0-9'\(\)\+\_,\-\.\/:=\?^\s]+)"?/
+        self.bound = $1
+        chunks = body.to_s.split(/--#{self.bound}(--)?\r?\n/)
+        self.content = chunks.shift.to_s.gsub(/\s+$/, '')
+        self.content << "\r\n" unless self.content.empty?
+
+        chunks.each do |chunk|
+          break if chunk == "--"
+          head,body = chunk.split(/\r?\n\r?\n/, 2)
+          part = Rex::MIME::Part.new
+          part.header.parse(head)
+          part.content = body.gsub(/\s+$/, '')
+          self.parts << part
+        end
+      else
+        self.content = body.to_s.gsub(/\s+$/, '') + "\r\n"
+      end
+    end
+  end
+
+  def to
+    (self.header.find('To') || [nil, nil])[1]
+  end
+
+  def to=(val)
+    self.header.set("To", val)
+  end
+
+  def from=(val)
+    self.header.set("From", val)
+  end
+
+  def from
+    (self.header.find('From') || [nil, nil])[1]
+  end
+
+  def subject=(val)
+    self.header.set("Subject", val)
+  end
+
+  def subject
+    (self.header.find('Subject') || [nil, nil])[1]
+  end
+
+  def mime_defaults
+    self.header.set("MIME-Version", "1.0")
+    self.header.set("Content-Type", "multipart/mixed; boundary=\"#{self.bound}\"")
+    self.header.set("Subject", '') # placeholder
+    self.header.set("Date", Time.now.strftime("%a,%e %b %Y %H:%M:%S %z"))
+    self.header.set("Message-ID",
+      "<"+
+      Rex::Text.rand_text_alphanumeric(rand(20)+40)+
+      "@"+
+      Rex::Text.rand_text_alpha(rand(20)+3)+
+      ">"
+    )
+    self.header.set("From", '')    # placeholder
+    self.header.set("To", '')      # placeholder
+  end
+
+
+  def add_part(data='', content_type='text/plain', transfer_encoding="8bit", content_disposition=nil)
+    part = Rex::MIME::Part.new
+
+    if content_disposition
+      part.header.set("Content-Disposition", content_disposition)
+    end
+
+    part.header.set("Content-Type", content_type) if content_type
+
+    if transfer_encoding
+      part.header.set("Content-Transfer-Encoding", transfer_encoding)
+    end
+
+    part.content = data
+    self.parts << part
+    part
+  end
+
+  def add_part_attachment(data, name)
+    self.add_part(
+      Rex::Text.encode_base64(data, "\r\n"),
+      "application/octet-stream; name=\"#{name}\"",
+      "base64",
+      "attachment; filename=\"#{name}\""
+    )
+  end
+
+
+  def add_part_inline_attachment(data, name)
+    self.add_part(
+      Rex::Text.encode_base64(data, "\r\n"),
+      "application/octet-stream; name=\"#{name}\"",
+      "base64",
+      "inline; filename=\"#{name}\""
+    )
+  end
+
+  def to_s
+    header_string = self.header.to_s
+
+    msg = header_string.empty? ? '' : force_crlf(self.header.to_s + "\r\n")
+    msg << force_crlf(self.content + "\r\n") unless self.content.to_s.strip.empty?
+
+    self.parts.each do |part|
+      msg << force_crlf("--" + self.bound + "\r\n")
+      msg << part.to_s
+    end
+
+    msg << force_crlf("--" + self.bound + "--\r\n") if self.parts.length > 0
+
+    msg
+  end
+
+end
+end
+end
+
Index: metasploit-framework-4.12.23/lib/rex/mime/part.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/lib/rex/mime/part.rb
@@ -0,0 +1,50 @@
+# -*- coding: binary -*-
+module Rex
+module MIME
+class Part
+
+  require 'rex/mime/header'
+  require 'rex/mime/encoding'
+
+  include Rex::MIME::Encoding
+
+  attr_accessor :header, :content
+
+  def initialize
+    self.header = Rex::MIME::Header.new
+    self.content = ''
+  end
+
+  def to_s
+    self.header.to_s + "\r\n" + content_encoded + "\r\n"
+  end
+
+  # Returns the part content with any necessary encoding or transformation
+  # applied.
+  #
+  # @return [String] Content with encoding or transformations applied.
+  def content_encoded
+    binary_content? ? content : force_crlf(content)
+  end
+
+  # Answers if the part content is binary.
+  #
+  # @return [Boolean] true if the part content is binary, false otherwise.
+  def binary_content?
+    transfer_encoding && transfer_encoding == 'binary'
+  end
+
+  # Returns the Content-Transfer-Encoding of the part.
+  #
+  # @return [nil] if the part hasn't Content-Transfer-Encoding.
+  # @return [String] The Content-Transfer-Encoding or the part.
+  def transfer_encoding
+    h = header.find('Content-Transfer-Encoding')
+    return nil if h.nil?
+
+    h[1]
+  end
+
+end
+end
+end
Index: metasploit-framework-4.12.23/metasploit-framework.gemspec
===================================================================
--- metasploit-framework-4.12.23.orig/metasploit-framework.gemspec
+++ metasploit-framework-4.12.23/metasploit-framework.gemspec
@@ -24,6 +24,9 @@ Gem::Specification.new do |spec|
   spec.homepage      = 'https://www.metasploit.com'
   spec.license       = 'BSD-3-clause'
 
+  spec.files         = `git ls-files`.split($/).reject { |file|
+    file =~ /^documentation|^data\/gui|^external/
+  }
   spec.bindir = '.'
   if ENV['CREATE_BINSTUBS']
     spec.executables   = [
Index: metasploit-framework-4.12.23/spec/lib/rex/mime/encoding_spec.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/spec/lib/rex/mime/encoding_spec.rb
@@ -0,0 +1,32 @@
+# -*- coding:binary -*-
+require 'spec_helper'
+
+require 'rex/mime'
+
+RSpec.describe Rex::MIME::Encoding do
+
+  subject do
+    mod = Class.new
+    mod.extend described_class
+    mod
+  end
+
+  describe "#force_crlf" do
+    it "deletes \\r characters" do
+      expect(subject.force_crlf("Test\r1\r")).to_not include("\\r")
+    end
+
+    it "substitutes \\n characters by \\r\\n sequences" do
+      expect(subject.force_crlf("Test 2\n")).to end_with("\r\n")
+    end
+
+    it "preserves \r\n sequences" do
+      expect(subject.force_crlf("\r\nTest 3\r\n")).to eq("\r\nTest 3\r\n")
+    end
+
+    it "first deletes \\r characters, then substitutes \\n characters" do
+      expect(subject.force_crlf("\rTest 4\r\n\r\r\n")).to eq("Test 4\r\n\r\n")
+    end
+  end
+
+end
Index: metasploit-framework-4.12.23/spec/lib/rex/mime/header_spec.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/spec/lib/rex/mime/header_spec.rb
@@ -0,0 +1,151 @@
+# -*- coding:binary -*-
+require 'spec_helper'
+
+require 'rex/mime'
+
+RSpec.describe Rex::MIME::Header do
+
+  let(:mime_headers_test) do
+    <<-EOS
+Content-Type: text/plain;
+Content-Disposition: attachment; filename="test.txt"
+    EOS
+  end
+
+  subject do
+    described_class.new
+  end
+
+  describe "#initialize" do
+    subject(:header_class) do
+      described_class.allocate
+    end
+
+    it "returns an Array" do
+      expect(header_class.send(:initialize)).to be_a(Array)
+    end
+
+    it "creates an empty headers array by default" do
+      expect(header_class.send(:initialize)).to be_empty
+    end
+
+    it "populates headers array with data from argument" do
+      header_class.send(:initialize, mime_headers_test)
+      expect(header_class.headers.length).to be(2)
+    end
+  end
+
+  describe "#add" do
+    it "returns the added entry" do
+      expect(subject.add('var', 'val')).to eq(['var', 'val'])
+    end
+
+    it "adds a new entry into the headers array" do
+      subject.add('var', 'val')
+      expect(subject.headers.length).to eq(1)
+    end
+  end
+
+  describe "#set" do
+    it "returns the set value" do
+      expect(subject.set('var', 'val')).to eq('val')
+    end
+
+    it "modifies the header entry if it exists" do
+      subject.add('var', 'val')
+      subject.set('var', 'val2')
+      expect(subject.headers.length).to eq(1)
+      expect(subject.headers[0]).to eq(['var', 'val2'])
+    end
+
+    it "creates the header entry if doesn't exist" do
+      subject.set('var2', 'val2')
+      expect(subject.headers.length).to eq(1)
+      expect(subject.headers[0]).to eq(['var2', 'val2'])
+    end
+  end
+
+  describe "#remove" do
+    it "doesn't remove any header if index doesn't exist" do
+      subject.add('var', 'val')
+      subject.remove(10000)
+      expect(subject.headers.length).to eq(1)
+    end
+
+    it "doesn't remove any header if var name doesn't exist" do
+      subject.add('var', 'val')
+      subject.remove('var2')
+      expect(subject.headers.length).to eq(1)
+    end
+
+    it "removes header entry if index exists" do
+      subject.add('var', 'val')
+      subject.remove(0)
+      expect(subject.headers.length).to eq(0)
+    end
+
+    it "removes any header entry with var name" do
+      subject.add('var', 'val')
+      subject.add('var2', 'val2')
+      subject.add('var', 'val3')
+      subject.remove('var')
+      expect(subject.headers.length).to eq(1)
+    end
+  end
+
+  describe "#find" do
+    it "returns nil if header index doesn't exist" do
+      expect(subject.find(1)).to be_nil
+    end
+
+    it "returns nil if header var name doesn't exist" do
+      expect(subject.find('var')).to be_nil
+    end
+
+    it "returns the header at index if exists" do
+      subject.add('var', 'val')
+      expect(subject.find(0)).to eq(['var', 'val'])
+    end
+
+    it "returns the first header with var name if exists" do
+      subject.add('var', 'val')
+      subject.add('var', 'val2')
+      subject.add('var', 'val3')
+      expect(subject.find('var')).to eq(['var', 'val'])
+    end
+  end
+
+  describe "#to_s" do
+    it "returns empty String if there aren't headers" do
+      expect(subject.to_s).to be_empty
+    end
+
+    it "returns string with headers separated by \\r\\n sequences" do
+      subject.add('var', 'val')
+      subject.add('var', 'val2')
+      subject.add('var3', 'val3')
+      expect(subject.to_s).to eq("var: val\r\nvar: val2\r\nvar3: val3\r\n")
+    end
+  end
+
+  describe "#parse" do
+    let(:complex_header) do
+      'Date: Wed,20 Aug 2014 08:45:38 -0500'
+    end
+
+    it "parses headers separated by lines" do
+      subject.parse(mime_headers_test)
+      expect(subject.headers.length).to eq(2)
+    end
+
+    it "parses headers names and values separated by :" do
+      subject.parse(mime_headers_test)
+      expect(subject.headers).to eq([['Content-Type', 'text/plain;'], ['Content-Disposition', 'attachment; filename="test.txt"']])
+    end
+
+    it "parses headers with ':' characters in the value" do
+      subject.parse(complex_header)
+      expect(subject.headers).to eq([['Date', 'Wed,20 Aug 2014 08:45:38 -0500']])
+    end
+  end
+end
Index: metasploit-framework-4.12.23/spec/lib/rex/mime/message_spec.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/spec/lib/rex/mime/message_spec.rb
@@ -0,0 +1,411 @@
+# -*- coding:binary -*-
+require 'spec_helper'
+
+require 'rex/mime'
+require 'rex/text'
+
+RSpec.describe Rex::MIME::Message do
+
+  subject do
+    described_class.new
+  end
+
+  describe "#initialize" do
+    subject(:message_class) do
+      described_class.allocate
+    end
+
+    let(:raw_message) do
+      message = "MIME-Version: 1.0\r\n"
+      message << "Content-Type: multipart/mixed; boundary=\"_Part_12_3195573780_381739540\"\r\n"
+      message << "Subject: Pull Request\r\n"
+      message << "Date: Wed,20 Aug 2014 08:45:38 -0500\r\n"
+      message << "Message-ID: <WRobqc7gEyQVIQwEkLS7FN3ZNhS1Xj9pU2szC24rggMg@tqUqGjjSLEvssbwm>\r\n"
+      message << "From: contributor@msfdev.int\r\n"
+      message << "To: msfdev@msfdev.int\r\n"
+      message << "\r\n"
+      message << "--_Part_12_3195573780_381739540\r\n"
+      message << "Content-Disposition: inline; filename=\"content\"\r\n"
+      message << "Content-Type: application/octet-stream; name=\"content\"\r\n"
+      message << "Content-Transfer-Encoding: base64\r\n"
+      message << "\r\n"
+      message << "Q29udGVudHM=\r\n"
+      message << "\r\n"
+      message << "--_Part_12_3195573780_381739540--\r\n"
+
+      message
+    end
+
+    it "creates a new Rex::MIME::Header" do
+      message_class.send(:initialize)
+      expect(message_class.header).to be_a(Rex::MIME::Header)
+    end
+
+    it "creates an empty array of parts" do
+      message_class.send(:initialize)
+      expect(message_class.parts).to be_empty
+    end
+
+    it "creates a random bound" do
+      message_class.send(:initialize)
+      expect(message_class.bound).to include('_Part_')
+    end
+
+    it "allows to populate headers from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.headers.length).to eq(7)
+    end
+
+    it "allows to create a MIME-Version header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('MIME-Version')).to eq(['MIME-Version', '1.0'])
+    end
+
+    it "allows to create a Content-Type header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('Content-Type')).to eq(['Content-Type', "multipart/mixed; boundary=\"_Part_12_3195573780_381739540\""])
+    end
+
+    it "allows to create a Subject header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('Subject')).to eq(['Subject', 'Pull Request'])
+    end
+
+    it "allows to create a Date header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('Date')).to eq(['Date', 'Wed,20 Aug 2014 08:45:38 -0500'])
+    end
+
+    it "allows to create a Message-ID header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('Message-ID')).to eq(['Message-ID', '<WRobqc7gEyQVIQwEkLS7FN3ZNhS1Xj9pU2szC24rggMg@tqUqGjjSLEvssbwm>'])
+    end
+
+    it "allows to create a From header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('From')).to eq(['From', 'contributor@msfdev.int'])
+    end
+
+    it "allows to create a To header from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.header.find('To')).to eq(['To', 'msfdev@msfdev.int'])
+    end
+
+    it "allows to populate parts from argument" do
+      message_class.send(:initialize, raw_message)
+      expect(message_class.parts.length).to eq(1)
+    end
+
+    it "allows to populate parts headers from argument" do
+      message_class.send(:initialize, raw_message)
+      part = message_class.parts[0]
+      expect(part.header.headers.length).to eq(3)
+    end
+
+    it "allows to populate parts contents from argument" do
+      message_class.send(:initialize, raw_message)
+      part = message_class.parts[0]
+      expect(part.content).to eq("Q29udGVudHM=")
+    end
+  end
+
+  describe "#to" do
+    it "returns nil if To: header doesn't exist" do
+      expect(subject.to).to be_nil
+    end
+
+    it "returns the To: header value if it exists" do
+      subject.header.add('To', 'msfdev')
+      expect(subject.to).to eq('msfdev')
+    end
+  end
+
+  describe "#to=" do
+    it "sets the To: header value" do
+      subject.to = 'msfdev'
+      expect(subject.to).to eq('msfdev')
+    end
+  end
+
+
+  describe "#from" do
+    it "returns nil if From: header doesn't exist" do
+      expect(subject.from).to be_nil
+    end
+
+    it "returns the From: header value if it exists" do
+      subject.header.add('From', 'msfdev')
+      expect(subject.from).to eq('msfdev')
+    end
+  end
+
+  describe "#from=" do
+    it "sets the From: header value" do
+      subject.from = 'msfdev'
+      expect(subject.from).to eq('msfdev')
+    end
+  end
+
+  describe "#subject" do
+    it "returns nil if Subject: header doesn't exist" do
+      expect(subject.subject).to be_nil
+    end
+
+    it "returns the Subject: header value if it exists" do
+      subject.header.add('Subject', 'msfdev')
+      expect(subject.subject).to eq('msfdev')
+    end
+  end
+
+  describe "#subject=" do
+    it "sets the Subject: header value" do
+      subject.subject = 'msfdev'
+      expect(subject.subject).to eq('msfdev')
+    end
+  end
+
+  describe "#mime_defaults" do
+    it "sets the MIME-Version header" do
+      subject.mime_defaults
+      expect(subject.header.find('MIME-Version')).to_not be_nil
+    end
+
+    it "sets the MIME-Version header to '1.0'" do
+      subject.mime_defaults
+      expect(subject.header.find('MIME-Version')).to eq(['MIME-Version', '1.0'])
+    end
+
+    it "sets the Content-Type header" do
+      subject.mime_defaults
+      expect(subject.header.find('Content-Type')).to_not be_nil
+    end
+
+    it "sets the Content-Type header to multipart/mixed" do
+      subject.mime_defaults
+      expect(subject.header.find('Content-Type')[1]).to include('multipart/mixed')
+    end
+
+    it "sets the Subject header" do
+      subject.mime_defaults
+      expect(subject.header.find('Subject')).to_not be_nil
+    end
+
+    it "sets the Subject header to empty string" do
+      subject.mime_defaults
+      expect(subject.header.find('Subject')).to eq(['Subject', ''])
+    end
+
+    it "sets the Message-ID header" do
+      subject.mime_defaults
+      expect(subject.header.find('Message-ID')).to_not be_nil
+    end
+
+    it "sets the From header" do
+      subject.mime_defaults
+      expect(subject.header.find('From')).to_not be_nil
+    end
+
+    it "sets the From header to empty string" do
+      subject.mime_defaults
+      expect(subject.header.find('From')).to eq(['From', ''])
+    end
+
+    it "sets the To header" do
+      subject.mime_defaults
+      expect(subject.header.find('To')).to_not be_nil
+    end
+
+    it "sets the To header to empty string" do
+      subject.mime_defaults
+      expect(subject.header.find('To')).to eq(['To', ''])
+    end
+  end
+
+  describe "#add_part" do
+    subject(:part) do
+      described_class.new.add_part(*args)
+    end
+
+    let(:args) { [] }
+
+    it "returns the new part" do
+      expect(part).to be_a(Rex::MIME::Part)
+    end
+
+    it "set part's Content-Type to text/plain by default" do
+      expect(part.header.find('Content-Type')[1]).to eq('text/plain')
+    end
+
+    it "set part's Content-Transfer-Encoding to 8bit by default" do
+      expect(part.header.find('Content-Transfer-Encoding')[1]).to eq('8bit')
+    end
+
+    it "doesn't set part's Content-Disposition by default" do
+      expect(part.header.find('Content-Disposition')).to be_nil
+    end
+
+    context "with Content-Type argument" do
+      let(:args) { ['', 'application/pdf'] }
+
+      it "creates a part Content-Type header" do
+        expect(part.header.find('Content-Type')[1]).to eq('application/pdf')
+      end
+    end
+
+    context "with Content-Transfer-Encoding argument" do
+      let(:args) { ['', 'application/pdf', 'binary'] }
+
+      it "creates a part Content-Transfer-Encoding header" do
+        expect(part.header.find('Content-Transfer-Encoding')[1]).to eq('binary')
+      end
+    end
+
+    context "with Content-Disposition argument" do
+      let(:args) { ['', 'application/pdf', 'binary', 'attachment; filename="fname.ext"'] }
+
+      it "creates a part Content-Disposition header" do
+        expect(part.header.find('Content-Disposition')[1]).to eq('attachment; filename="fname.ext"')
+      end
+    end
+
+    context "with content argument" do
+      let(:args) { ['msfdev'] }
+
+      it "creates part content" do
+        expect(part.content).to eq('msfdev')
+      end
+    end
+
+  end
+
+  describe "#add_part_attachment" do
+    it "requires data argument" do
+      expect { subject.add_part_attachment }.to raise_error(ArgumentError)
+    end
+
+    it "requires name argument" do
+      expect { subject.add_part_attachment('data') }.to raise_error(ArgumentError)
+    end
+
+    it 'returns the new Rex::MIME::Part' do
+      expect(subject.add_part_attachment('data', 'name')).to be_a(Rex::MIME::Part)
+    end
+
+    it 'encodes the part content with base64' do
+      part = subject.add_part_attachment('data', 'name')
+      expect(part.content).to eq(Rex::Text.encode_base64('data', "\r\n"))
+    end
+
+    it 'setup Content-Type as application/octet-stream' do
+      part = subject.add_part_attachment('data', 'name')
+      expect(part.header.find('Content-Type')[1]).to eq('application/octet-stream; name="name"')
+    end
+
+    it 'setup Content-Transfer-Encoding as base64' do
+      part = subject.add_part_attachment('data', 'name')
+      expect(part.header.find('Content-Transfer-Encoding')[1]).to eq('base64')
+    end
+
+    it 'setup Content-Disposition as attachment' do
+      part = subject.add_part_attachment('data', 'name')
+      expect(part.header.find('Content-Disposition')[1]).to eq('attachment; filename="name"')
+    end
+  end
+
+  describe "#add_part_inline_attachment" do
+    it "requires data argument" do
+      expect { subject.add_part_inline_attachment }.to raise_error(ArgumentError)
+    end
+
+    it "requires name argument" do
+      expect { subject.add_part_inline_attachment('data') }.to raise_error(ArgumentError)
+    end
+
+    it 'returns the new Rex::MIME::Part' do
+      expect(subject.add_part_inline_attachment('data', 'name')).to be_a(Rex::MIME::Part)
+    end
+
+    it 'encodes the part content with base64' do
+      part = subject.add_part_inline_attachment('data', 'name')
+      expect(part.content).to eq(Rex::Text.encode_base64('data', "\r\n"))
+    end
+
+    it 'setup Content-Type as application/octet-stream' do
+      part = subject.add_part_inline_attachment('data', 'name')
+      expect(part.header.find('Content-Type')[1]).to eq('application/octet-stream; name="name"')
+    end
+
+    it 'setup Content-Transfer-Encoding as base64' do
+      part = subject.add_part_inline_attachment('data', 'name')
+      expect(part.header.find('Content-Transfer-Encoding')[1]).to eq('base64')
+    end
+
+    it 'setup Content-Disposition as attachment' do
+      part = subject.add_part_inline_attachment('data', 'name')
+      expect(part.header.find('Content-Disposition')[1]).to eq('inline; filename="name"')
+    end
+  end
+
+  describe "#to_s" do
+    let(:regexp_mail) do
+      regex = "MIME-Version: 1.0\r\n"
+      regex << "Content-Type: multipart/mixed; boundary=\"_Part_.*\"\r\n"
+      regex << "Subject: Pull Request\r\n"
+      regex << "Date: .*\r\n"
+      regex << "Message-ID: <.*@.*>\r\n"
+      regex << "From: contributor@msfdev.int\r\n"
+      regex << "To: msfdev@msfdev.int\r\n"
+      regex << "\r\n"
+      regex << "--_Part_.*\r\n"
+      regex << "Content-Disposition: inline\r\n"
+      regex << "Content-Type: text/plain\r\n"
+      regex << "Content-Transfer-Encoding: base64\r\n"
+      regex << "\r\n"
+      regex << "Q29udGVudHM=\r\n"
+      regex << "\r\n"
+      regex << "--_Part_.*--\r\n"
+
+      Regexp.new(regex)
+    end
+
+    let(:regexp_web) do
+      regex = "--_Part_.*\r\n"
+      regex << "Content-Disposition: form-data; name=\"action\"\r\n"
+      regex << "\r\n"
+      regex << "save\r\n"
+      regex << "--_Part_.*\r\n"
+      regex << "Content-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\r\n"
+      regex << "Content-Type: application/octet-stream\r\n"
+      regex << "\r\n"
+      regex << "Contents\r\n"
+      regex << "--_Part_.*\r\n"
+      regex << "Content-Disposition: form-data; name=\"title\"\r\n"
+      regex << "\r\n"
+      regex << "Title\r\n"
+      regex << "--_Part_.*--\r\n"
+
+      Regexp.new(regex)
+    end
+
+    it "returns empty string if Rex::MIME::Message is empty" do
+      expect(subject.to_s).to be_empty
+    end
+
+    it "generates valid MIME email messages" do
+      subject.mime_defaults
+      subject.from = "contributor@msfdev.int"
+      subject.to = "msfdev@msfdev.int"
+      subject.subject = "Pull Request"
+      subject.add_part(Rex::Text.encode_base64("Contents", "\r\n"), "text/plain", "base64", "inline")
+      expect(regexp_mail.match(subject.to_s)).to_not be_nil
+    end
+
+    it "generates valid MIME web forms" do
+      subject.add_part("save", nil, nil, "form-data; name=\"action\"")
+      subject.add_part("Contents", "application/octet-stream", nil, "form-data; name=\"file\"; filename=\"test.txt\"")
+      subject.add_part("Title", nil, nil, "form-data; name=\"title\"")
+      expect(regexp_web.match(subject.to_s)).to_not be_nil
+    end
+  end
+
+end
Index: metasploit-framework-4.12.23/spec/lib/rex/mime/part_spec.rb
===================================================================
--- /dev/null
+++ metasploit-framework-4.12.23/spec/lib/rex/mime/part_spec.rb
@@ -0,0 +1,92 @@
+# -*- coding:binary -*-
+require 'spec_helper'
+
+require 'rex/mime'
+
+RSpec.describe Rex::MIME::Part do
+
+  subject do
+    described_class.new
+  end
+
+  describe "#initialize" do
+    subject(:part_class) do
+      described_class.allocate
+    end
+
+    it "initializes the Rex::MIME::Header object" do
+      part_class.send(:initialize)
+      expect(part_class.header).to be_a(Rex::MIME::Header)
+    end
+
+    it "initializes the Rex::MIME::Header with an empty array of headers" do
+      part_class.send(:initialize)
+      expect(part_class.header.headers).to be_empty
+    end
+
+    it "Initializes content with an empty String" do
+      part_class.send(:initialize)
+      expect(part_class.content).to be_empty
+    end
+  end
+
+  describe "#transfer_encoding" do
+    it "returns nil if the part hasn't a Content-Transfer-Encoding header" do
+      expect(subject.transfer_encoding).to be_nil
+    end
+
+    it "returns the transfer encoding value if a Content-Transfer-Encoding header exists" do
+      subject.header.add('Content-Transfer-Encoding', 'base64')
+      expect(subject.transfer_encoding).to eq('base64')
+    end
+  end
+
+  describe "#binary_content?" do
+    it "returns false if transfer encoding isn't defined" do
+      expect(subject.binary_content?).to be_falsey
+    end
+
+    it "returns false if transfer encoding isn't binary" do
+      subject.header.add('Content-Transfer-Encoding', 'base64')
+      expect(subject.binary_content?).to be_falsey
+    end
+
+    it "returns true if transfer encoding is binary" do
+      subject.header.add('Content-Transfer-Encoding', 'binary')
+      expect(subject.binary_content?).to be_truthy
+    end
+  end
+
+  describe "#content_encoded" do
+    let(:content_test) do
+      "\rTest1\n"
+    end
+
+    it "returns the exact content if transfer encoding is binary" do
+      subject.header.add('Content-Transfer-Encoding', 'binary')
+      subject.content = content_test
+      expect(subject.content_encoded).to eq(content_test)
+    end
+
+    it "returns the content crlf encoded if transfer encoding isn't binary" do
+      subject.content = content_test
+      expect(subject.content_encoded).to eq("Test1\r\n")
+    end
+  end
+
+  describe "#to_s" do
+    it "returns headers and content separated by two \\r\\n sequences" do
+      subject.header.add('var', 'val')
+      subject.content = 'content'
+      expect(subject.to_s).to eq("var: val\r\n\r\ncontent\r\n")
+    end
+
+    it "returns two \\r\\n sequences if part is empty" do
+      expect(subject.to_s).to eq("\r\n\r\n")
+    end
+
+    it "ends with \\r\\n sequence" do
+      expect(subject.to_s).to end_with("\r\n")
+    end
+  end
+end
